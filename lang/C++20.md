

# C++20

[TOC]

Table of Contents
=================

* [C\+\+20](#c20)
* [Table of Contents](#table-of-contents)
  * [Modules](#modules)
    * [Submodule](#submodule)
    * [Modul\-Partitionen](#modul-partitionen)
  * [Coroutines](#coroutines)
  * [Concepts](#concepts)
  * [Ranges](#ranges)
  * [Vergleichsoperator &lt;=&gt; und](#vergleichsoperator--und)
  * [Designated Initializers](#designated-initializers)
  * [String\-Literale als Template\-Parameter](#string-literale-als-template-parameter)
  * [constexpr virtuelle Funktionen](#constexpr-virtuelle-funktionen)
  * [Lambda improvements](#lambda-improvements)
  * [Template improvements](#template-improvements)
  * [Range\-based for\-loop with initializer](#range-based-for-loop-with-initializer)
  * [Attribute](#attribute)
  * [consteval und constinit](#consteval-und-constinit)
  * [constexpr\-container and algorithms](#constexpr-container-and-algorithms)
  * [Concurrency](#concurrency)
    * [std::atomic](#stdatomic)
    * [Floating point atomics](#floating-point-atomics)
    * [Semaphoren, Latches und Barriers](#floating-point-atomics)
    * [std::jthread](#stdjthread)
  * [use of using enum](#use-of-using-enum)
  * [volatile](#volatile)
  * [UTF\-8 Strings: char8\_t](#utf-8-strings-char8_t)
  * [Bitfeld Default\-Initialisierung](#bitfeld-default-initialisierung)
  * [Bit\-Manipulationen](#bit-manipulationen)
    * [std::endian](#stdendian)
	* [Manipulationen](#manipulationen)
  * [Algorithmen](#algorithmen)
  * [Version](#version)
  * [Bibliothek](#bibliothek)
    * [chrono](#chrono)
    * [utilities](#utilities)
    * [numbers](#numbers)	
    * [span](#span)
    * [format](#format)
    * [std::erase und std::erase_if](#stderase-und-stderas_if)
    * [std::contains for associative containers](#stdcontains-for-associative-containers)
    * [std::midpoint](#stdmidpoint)
    * [std::lerp](#stdlerp)
    * [std::to_array](#stdto_array)
    * [std::make_shared](#stdmake_shared)
    * [std::string starts_with and ends_with](#stdstring-starts_with-and-ends_with)
    * [std::bind_front](#stdbind_front)
    * [std::is_constant_evaluated](#stdis_constant_evaluated)
    * [std::source_location](#stdsource_location)
  * [Literatur](#literatur)

Created by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc.go)



## Modules

Module stellen eine Alternative zu Header-Dateien dar. Siehe auch das Modulkonzept in anderen Sprachen, z.B. Python. Die Vorteile liegen auf der Hand:

- Ein Modul wird nur einmal importiert. 
- Es stellt keinen Unterschied dar, in welcher Reihenfolge Module importiert werden.
- Die Trennung von Header- und Quelldateien aufzulösen
- Verzicht auf Präprozessor-Anweisungen
- Abhängigkeiten von include-Anweisungen zu eliminieren
- schnellere Kompilierzeiten

Aktuell verwendet Clang die Endung .cppm für Modulnamen, während cl.exe das Suffix .ixx verwendet. Das folgende Beispiel erstelle ich mit Clang. Mit gcc hatte ich bisher keinen Erfolg mit Modulen. Zuerst die Modul-Datei math.cppm.

```c++
// math.cppm

// #include <...> here you can still include old-fashioned header files

// this is our module declaration
export module math;

// import other_modules; here you can import other modules if appropriate

// now implement math functions 

// non-exported declarations
void foo()
{
    // only visible inside the module
}

// greatest common divisor
export int gcd(int first, int second)
{
   // using the Euclidean algorithm
   return second == 0 ? first : gcd(second, first % second);
} 

// least common multiple
export int lcm(int first, int second)
{
   int div = gcd(first, second); 
   return div ? (first * (second / div)) : 0;
}
```

Was gibt es in der Modul-Datei für interessante Dinge zu sehen?

- In Modulen lassen sich andere Module importieren. Diese haben dann Modulbindung, d.h. sind nicht von außerhalb des Moduls sichtbar
- #include Direktive können weiterhin benutzt werden
- Deklarationen können exportiert werden oder auch nicht. Nicht-exportierte Deklarationen sind nur sichtbar innerhalb des Moduls.

Und noch unsere main.cpp.

```C++
// main.cpp
#include "stdio.h"

// Our first C++20 module - of course a math module
import math;

int main()
{   
   // call greatest common divisor from math module
   int res = gcd(2000, 20);
   printf("gcd %d\n", res);
   
   // call least common multiple from math module
   res = lcm(10, 100);
   printf("lcm %d", res);
}
```

Jetzt noch schnell kompilieren, um zu beweisen, dass es auch funktioniert. Ich benutze den Clang 10.0.0 Compiler dafür. 

```pseudocode
>>> clang++.exe -v
>>> clang version 10.0.0
>>> Target: x86_64-pc-windows-msvc
>>> Thread model: posix
>>> InstalledDir: d:\Program Files\LLVM\bin
```

Es geht los. 

```pseudocode
/// Erzeuge aus der Moduledeklaration math.cppm ein vorcompiliertes Modul math.pcm.
>>> clang++.exe -std=c++20 --precompile math.cppm -o math.pcm 

/// Erzeuge eine Übersetzungseinheit math.o, die kein Modul darstellt.
>>> clang++.exe -std=c++20 -c math.pcm -o math.o

/// Erzeuge eine ausführbare Datei math oder math.exe. clang++ benötigt hier noch den Pfad zum Modul.
>>> clang++.exe -std=c++20 -fmodules-ts -fprebuilt-module-path=. math.o main.cpp -o math.exe

/// math.exe ist ausführbar - und die Algorithmen sind korrekt. 
>>> math.exe 
>>> gcd 20
>>> lcm 100
```

Es gibt noch einige Goodies, die ich hier anmerken will, die ich aber selbst noch nicht ausprobiert habe. 

### Submodule

Ein Modul kann ein Modul importieren und wieder zurückexportieren. 

```c++
// math.cppm

// this is our module declaration
export module math;

// import other modules and re-export them again as part of module math
export import math.math1;
export import math.math2;

```

### Modul-Partitionen

Ein Modul lässt sich in Partitonen aufteilen.

## Coroutines

*Coroutinen* unterstützen die asynchrone Programmierung. Es handelt sich um Funktionen, die ihre Ausführung anhalten und wieder aufnehmen können. Dabei behalten sie ihren Zustand. 

C++20 liefert keine konkreten *Coroutinen*, sondern ein Framework für das Schreiben von *Coroutinen*. Für eine existierende Coroutinen-Bibliothek schaue dir einmal [20] an.

Es gibt neue Schlüsselwörter:

- *co_await*: Wenn man co_await expression in einer Funktion res = func() verwendet, blockiert der Aufruf res = func() nicht, falls das Ergebnis noch nicht zur Verfügung steht. Ein ressourcenintensives Warten wird damit zu einem ressourcenfreundlichen Warten.
- *co_yield*: Mit co_yield kann man eine Generatorfunktion schreiben. Diese gibt bei jedem Aufruf einen Wert zurück. Es ist eine Art Datenstrom, von dem sich jederzeit und sukzessive Werte auslesen lassen.
- *co_return*: Verwende co_return um eine Coroutine zu beenden und einen Rückgabewert zu liefern.

```C++
Acceptor accept{443};

while (true)
{
    Socket so = co_await accept.accept();
    auto req = co_await so.read();
    auto resp = handleRequest(req);
    co_await so.write(resp);
}
```

Ein Aufruf wie *auto req = co_await so.read* wartet nicht, bis die Daten verfügbar sind. Stattdessen kommt er sofort zurück und setzt seine Arbeit dann fort, wenn Daten tatsächlich verfügbar sind. 

```c++
#include <iostream>

generator<int> getNextInt(int begin = 0)
{
  for (int i = begin;; ++i)
  {
      co_yield i;
  }
}

int main() 
{    
    std::cout << std::endl;
  
    std::cout << "getNextInt():";
	const auto gen = getNextInt();
    for (int i = 0; i <= 10; ++i) 
    {         
        std::cout << "numbers " << gen << " ";                  
    }
   
   std::cout << std::endl;
}
```

Im obigen Beispiel ist *getNextInt* eine Coroutine. *getNextInt* besitzt eine Endlosschleife, die den Wert nach *co_yield* zurückgibt. Ein Aufruf *getNextInt()* weckt die Coroutine, mit *getValue()* kann danach der Wert abgeholt werden. 

Eine ausführbare Version der Coroutines von Rainer Grimm findest du bei [21].

## Concepts

*Concepts* sind eine Erweiterung der Templates und sind Bestandteil von C++20. Zusätzlich wird eine vereinfachte Syntax eingeführt.  

*Concepts* sind Prädikate zur Compile-Zeit. Sie werden während der Übersetzung evaluiert und liefern einen Wahrheitswert. 

Damit ist es möglich, Anforderungen an die Templates als Teil des Interfaces zu formulieren. Dadurch sollten kryptische Fehlermeldungen des Compilers bei Instanziierung eines Templates mit fehlerhaftem Datentyp Vergangenheit sein. 

Du kannst vordefinierte *Concepts* verwenden oder deine eigenen *Concepts* definieren.

In den folgenden Beispielen wird das Concept *Integral* verwendet. 

```c++
/// C++20: concepts
#include <iostream>
#include <concepts>

// concept using a Require Clause
template<typename T> requires std::integral<T>
T ggt(T a, T b)
{
  if (b == 0)
  {
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
}

///> ggt is 4
```

Der Template-Parameter T muß ein *Integral* sein. Man kann das Ganze noch abkürzen. 

```c++
/// C++20: concepts
#include <iostream>
#include <concepts>

// concept using Contrained Template Parameters
template<std::integral T>
T ggt(T a, T b)
{
  if (b == 0)
  { 
      return a; 
  }
  else
  {
  	return ggt(b, a % b);
  }
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
}

///> ggt is 4
```

Die Definition des *Concept* *Integral* sieht folgendermaßen aus. 

```c++
template<typename T> concept Integral = std::is_integral<T>::value; 
```

Damit kann ich auch meine eigenen *Concepts* definieren.

```c++
/// C++20: user-defined concepts
#include <iostream>
#include <concepts>
#include <type_traits>
#include <vector>

template<typename T> concept MyIntegral = std::is_integral<T>::value;

MyIntegral auto getIntegral(int val)
{
   return val;
}

/// Example for a Concept as Template Paramter
template<MyIntegral T> T ggt(T a, T b)
{
   if (b == 0)
   { 
      return a; 
   }	
   else
   {
      return ggt(b, a % b);
   }
}

/// Example for a Concept as Function Parameter
bool isEqual(MyIntegral auto first, MyIntegral auto second)
{
   return (first == second);
}

int main()
{
   auto res = ggt(8, 12);
    
   std::cout << "ggt is " << res << "\n";
    
   std::vector<int> vec{1, 2, 3, 4, 5};
   for (MyIntegral auto i: vec)
   {
      std::cout << i << " ";
   }
 
   std::cout << std::boolalpha << std::endl;
    
   MyIntegral auto b = true; 
   std::cout << b << "\n";
   
   /// Concept as function parameter
   bool integral_equals = isEqual(42, 42);
   std::cout << integral_equals << std::endl;
}

///> ggt is 4
///> 1 2 3 4 5 
///> true
///> true
```

Es lohnt sich definitiv, sich damit zu beschäftigen und zu schauen, welche *Concepts* schon vordefiniert sind. Man will ja nicht *Concepts* definieren, die schon vordefiniert sind. Im folgenden eine (nicht zwingendermaßen vollständige) Übersicht der vordefinierten *Concepts*.

| Concept                                                      | Beschreibung                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| three_way_comparable, three_way_comparable_with              | Unterstützt den Drei-Wege-Vergleichsoperator <=>. three_way_comparable_with erlaubt den Vergleich von Werten mit verschiedenen Datentypen, z.B. 1.0 < 1.0f |
| same_as, derived_from, convertible_to, common_reference_with, common_with, assignable_from, swappable |                                                              |
| integral, signed_integral, unsigned_integral, floating_point |                                                              |
| destructible, constructible_from, default_constructible, move_constructable, copy_constructable |                                                              |
| boolean, totally_ordered                                     |                                                              |
| equality_comparable, equality_comparable_with                | Concept unterstützt den Gleichheits-Operator ==. equality_comparable_with unterstützt den Vergleich von Werten mit verschiedenen Datentypen, z.B 1.0==1.0f |
| movable, copyable, semiregular, regular                      |                                                              |
| invocable, regular_invocable, predicate                      |                                                              |
| input_iterator, output_iterator, forward_iterator, bidirectional_iterator, random_access_iterator, contiguous_iterator |                                                              |
| permutable, mergeable, sortable                              |                                                              |
| uniform_random_bit_generator                                 |                                                              |

## Ranges

Die Bibliothek erlaubt es, wie schon von anderen Sprachen bekannt (z.B. Python), die Algorithmen der Standard Template Library direkt auf Containern auszuführen. Algorithmen lassen sich mit dem Pipe-Symbol ("|") verknüpfen und die Auswertung kann erst bei Nachfrage erfolgen (*lazy evaluation*).  In kurz - Ranges unterstützen Algorithmen, die 

- auf dem ganzen Container arbeiten
- *lazy* evaluiert werden
- komponiert werden können

```c++
/// C++20 ranges and views
#include <vector>
#include <ranges>
#include <iostream>
 
/// Example of C++20 ranges and views
int main()
{
   std::vector<int> ints{0, 1, 2, 3, 4, 5};
   /// only even numbers 
   auto even = [](int i){ return 0 == i % 2; };
   /// square of number
   auto square = [](int i) { return i * i; };
 
   /// here ints is the Range and std::views::filter + std::views::transform are the Views
   for (int i : ints | std::views::filter(even) | std::views::transform(square)) 
   {
      std::cout << i << ' ';             // 0 4 16
   }
}

//> 0 4 16
```

Innerhalb der for-Anweisung sieht man die Funktionskomposition mit dem Pipe-Symbol, die man von links nach rechts lesen muss. Wende für jedes Element von *ints* den Filter *even* an (also alle *ints*, die gerade sind) und bilde die verbleibenden Argumente auf ihr Quadrat ab. 

In C++20 wurde dafür die Standardbibliothek Ranges eingeführt, die die Konzepte *Range* und *Views* implementiert. 

**Range**

Ein *Range* ist eine Menge von Elementen, über die iteriert werden kann. Ein *Range* besitzt einen *begin-iterator* und ein *Sentinel* (Abschlusselement). Die Container der Standard-Bibliothek sind *Ranges*. Dazu gibt es weitere Verfeinerungen von *Ranges*. 

**Views**

Ein *View* lässt sich auf einem *Range* anwenden. Dabei wird eine Operation ausgeführt. 

## Vergleichsoperator <=> und

Der Vergleichsoperator <=> bestimmt für zwei Werte A und B, ob A<B, A=B oder A>B ist. Der Compiler kann den Drei-Wege-Vergleichsoperator automatisch erzeugen, indem er mit dem Schlüsselwort *default* darauf hingewiesen wird. Dadurch bietet er alle sechs Vergleichsoperatoren: ==, !=, <, <=, >, >=. Details findet man auch auf [10].

Ebenso kann man den Vergleichsoperator selbst definieren.

Der Vergleichsoperator wird auch *Spaceship Operator* genannt.

```c++
// C++20 Spaceship Operator
#include <iostream>
#include <compare> // this one is need for the Spaceship Operator to work

/// Let Spaceship operator implement by compiler
struct SpaceshipByCompiler
{
   int value; 
   explicit SpaceshipByCompiler(int v) {value=v;}
   auto operator<=>(const SpaceshipByCompiler& rhs) const = default; 
}; 

/// Let Spaceship operator implement on our own
struct SpaceshipByMe
{
   int value; 
   explicit SpaceshipByMe(int v) {value=v;}
   auto operator<=>(const SpaceshipByMe& rhs) const
   {
      return value<=>rhs.value;
   }
}; 

int main()
{
   SpaceshipByCompiler a(4);
   SpaceshipByCompiler b(4); 
   
   if (a == b)
   {
      std::cout << "a equals b\n";
   }
    
    SpaceshipByMe c(5);
    SpaceshipByMe d(3);
    
    if (c > d)
    {
       std::cout << "c greater d" << std::endl;
    }
   
   return 0;
}

///>>> a equals b
///>>> c greater d
```

Tatsächlich lässt sich der Spaceship-Operator auch direkt anwenden. Was ich persönlich für eine richtige coole Option finde. 

```c++
// C++20 Spaceship Operator
#include <iostream>
#include <compare> // this one is need for the Spaceship Operator to work

int main()
{    
    std::cout << std::endl;
    
    int a(2011);
    int b(2014);
    // here: use spaceship operator - all compare operators are now defined
    auto res = a <=> b;                 
    // then just use compare operators to check if smaller, greater, equall, and so on...
    if (res < 0) std::cout << "a < b" << std::endl;
    else if (res == 0) std::cout << "a == b" << std::endl;
    else if (res > 0) std::cout << "a > b" << std::endl;

    std::cout << std::endl;
}

/// a < b
```



## Designated Initializers  

Mit diesem Feature können (unter anderem) Teile eines *struct* definiert werden. *Designated Initializers* sind eine Erweiterung der *Aggregate Initializers* aus C++11. 

```C++
// C++20 Designated Initializer
#include <iostream>

int main()
{
   struct Point
   {
      int x; 
      int y; 
   };
   
   // C++11 initialisation
   Point point {1, 1};  
   
   std::cout << "Point " << point.x << " " << point.y << std::endl;
   
   // C++20 Designated Initializer
   Point point2 {.x = 2, .y = 2};
    
   std::cout << "Point " << point2.x << " " << point2.y << std::endl;
    
   // C++20 also possible - but compiler should place a warning - default initialization to 0
   Point point3 {.x =2};
   
   std::cout << "Point " << point3.x << " " << point3.y << std::endl;
   
   return 0;
}

///> Point 1 1
///> Point 2 2
///> Point 2 0
```

## String-Literale als Template-Parameter

Man konnte bisher einen String nicht als Template-Parameter einsetzen (außer typisierten Templates). Mit C++20 ist dies nun möglich. Es bietet sich an, den im Standard definierten *basic_fixed_string* zu nehmen, da dieser einen *constexpr*-Konstruktor besitzt. 

```c++
/// C++20: String-Literale als Template-Parameter
template<std::basic_fixed_string T> 
class Foo 
{
   static constexpr char const* Name = T;
   public:
      void hello() const;
};

int main() 
{
   Foo<"Hello!"> foo;
   foo.hello();
}

// Hello!
```

ACHTUNG: Bisher konnte ich es nicht zum Laufen bringen, da *basic_fixed_string* es wohl nicht in den C++20 Standard geschafft hat. Genaueres als Aufgabe für eine Recherche.

## constexpr virtuelle Funktionen

*constexpr* Funktionen durften bisher nicht virtuell sein. Diese Einschränkung fällt mit C++20 weg. 

```c++
// C++20 constexpr virtuelle Funktionen
#include <iostream>

struct X1 
{
    /// virtual base class function f()
    virtual int f() const = 0;
};

struct X2 : public X1 
{
    /// f() inherits from X1::f() and it is constexpr
    constexpr int f() const override { return 2; }
};

struct X3 : public X2 
{
    /// f() inherits from X2::f() where X2::f() is constexpr
    int f() const override { return 3; }
};

struct X4 : public X3 
{
    /// f() inherits from X
    constexpr int f() const override { return 4; }
};

int main() 
{
    X1* x1 = new X4;                          
    std::cout << "x1->f(): " << x1->f() << std::endl; 
    
    X4 x4;
    X1& x2 = x4;                              
    std::cout << "x2.f(): " << x2.f() << std::endl;
    
}

//> x1->f(): 4
//> x2.f(): 4
```



## Lambda improvements

Die **implizite Bindung von this** bei Verwendung von [=] ist Geschichte. 

```c++
/// C++20: Lambda improvements
#include <iostream>

struct Lambda 
{
   auto foo() 
   {
      // warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
      return [=] { std::cout << s << std::endl; };
      // warning: implicit capture of 'this' via '[=]' is deprecated in C++20 [-Wdeprecated]
   }

   std::string s;
};

struct LambdaCpp20 
{
   auto foo() 
   {
      // OK
      return [=, this] { std::cout << s << std::endl; };
   }

   std::string s;
};
```

**Template-Lambdas** 

Manchmal ist es notwendig, eine Lambda-Funktion zu definieren, die nur für bestimmte Datentypen verwendet werden kann. C++20 unterstützt dafür jetzt *Template-Lambdas*. 

```c++
/// C++20: Template Lambdas
#include <iostream>
#include <vector>

int main() 
{
   std::vector<int> my_int_vec = {1, 2, 3};
   std::vector<std::string> my_string_vec = {"a", "b", "c"};
   
   /// Lambda expecting a vector
   auto lambdaVector = []<typename T>(std::vector<T> const& vec) 
   { 
      return vec.size();
   };
   
   /// lambda expecting a vector with only integral values 
   auto lambdaVectorIntegral = []<std::integral T>(std::vector<T> const& vec)
   {
      return vec.size();
   };
   
   int res = 0;
   
   //res = lambdaVector(42); /// does not compile - error: no match for call to '(main()::<lambda(const std::vector<T>&)>) (int)'
   res = lambdaVector(my_int_vec);
   std::cout << "res " << res << std::endl;
   
   //res = lambdaVectorIntegral(my_string_vec); /// does not compile because vector does not contain integrals
   res = lambdaVectorIntegral(my_int_vec);
   std::cout << "res " << res << std::endl;
}

///> res 3
///> res 3
```

Details zu Lambda-Verbesserungen von C++11 bis C++20 können in [11] nachgelesen werden.

## Template improvements

Mit C++20 erhält man einige Template-Verbesserungen. 

**Bedingt expliziter Konstruktor** 

Ein generischer Konstruktor kann jetzt auch explizit (class Explicit) gemacht werden. Und zusätzlich noch bedingt explizit (class ExplicitBedingt).

```c++
/// C++20: explicit template constructor
#include <iostream>

class Implicit
{
public:
   template<class T> Implicit(T t) { std::cout << "param " << t << std::endl; }
};

class Explicit
{
public:
   // does only allow explicit calls but allows all types of parameters
   template<class T> explicit Explicit(T t) { std::cout << "param " << t << std::endl; }
};

class BedingtExplicit
{
public:
   // does only allow bool values as parameter
   template<class T> explicit(!std::is_same<T, bool>::value) BedingtExplicit(T t) { std::cout << "param " << t << std::endl; }
};

int main() 
{
   Implicit im = 1; // compiles as not made explicit
   //Explicit ex1 = 1; does not compile because of explicit
   Explicit ex(1);
   //BedingtExplicit bex = 1; does not compile because of explicit
   BedingtExplicit bex = true; // compiles because of 'bedingt' explicit
   
   static_cast<void>(im);
   static_cast<void>(bex);
}

///> param 1
///> param 1
///> param 1
```

**Neue Nichttype-Template Parameter**

Als Beispiel für einen neuen Nichttype-Template Parameter nehme ich die Fließkommazahlen. Diese werden jetzt auch als Template-Parameter akzeptiert. 

```c++
/// C++20: non-type template parameter
#include <iostream>

template <double d> auto getDouble() 
{
   return d;
}

int main() 
{

}
/// DOES NOT YET COMPILE USING gcc10.1 C++2a
```

## Range-based for-loop with initializer

The range-based for-loop can now directly be used with an initializer. 

```c++
// C++20 range-based for-loop with initializer
#include <iostream>
#include <vector>

int main()
{
    /// std::vector with initializer
    for (auto vec = std::vector{1, 2, 3}; auto v : vec) 
    {  
        std::cout << v << " ";
    }  

    std::cout << "\n"; 

    /// std::initializer_list
    for (auto initList = {1, 2, 3}; auto e : initList) 
    { 
        e *= e;
        std::cout << e << " ";
    }
    
    std::cout << "\n";

    using namespace std::string_literals;
    /// std::string_literal
    for (auto str = "Hello World"s; auto c: str) 
    { 
        std::cout << c << " ";
    }
}


//> 1 2 3
//> 1 4 9 
//> H e l l o   W o r l d 
```



## Attribute

| Attribut              | Beschreibung                                                 |
| --------------------- | ------------------------------------------------------------ |
| [[nodiscard"reason"]] | Wie [[nodiscard]] in C++17, nur kann man jetzt noch eine Nachricht hinzufügen. |
| [[likely]]            | Codepfad wird mit höherer Wahrscheinlichkeit ausgeführt      |
| [[unlikely]]          | Codepfad wird mit höherer Wahrscheinlichkeit nicht ausgeführt |
| [[no_unique_address]] | Drückt aus, dass dieses Mitglied einer Klasse keine Adresse benötigt,  die sich von allen anderen nichtstatischen Mitgliedern der Klasse  unterscheidet. |

**[[likely]] und [[unlikely]]**

Beide Attribute erlauben es, dem Compiler einen Hinweis zu geben,  welcher Ausführungspfad mit höherer Wahrscheinlichkeit ausgeführt wird.

```c++
/// C++20: Attributes
#include <iostream>
#include <vector>
#include <cmath>

int main() 
{
   double sum = 0.0;
   std::vector<int> numbers = {2, 3, 4, 5};
    
   for (size_t i=0; i < numbers.size(); ++i)
   {
      if (numbers[i] < 0) [[unlikely]] 
      {
         sum -= std::sqrt(-numbers[i]);
      }
      else 
      {
         sum += std::sqrt(numbers[i]);
      }
   }
    
    std::cout << "sum " << sum << std::endl; 
}

///> sum 7.38233
```

**[[nodiscard("reason")]]**

```c++
// C++17 [[no_discard attribute]]
#include <iostream>
#include <cstdlib>

// declard ErrorCode as [[nodiscard]]
enum class [[nodiscard("Don't discard the error code")]] ErrorCode {
    Okay,
    Warning,
    Critical,
    Fatal
};

// ErrorCode is [[nodiscard]] thus you're not allowed to discard the Error Return value
ErrorCode throwWarning() { return ErrorCode::Fatal; }

int main()
{
    // when calling throwWarning() without evaluate the return value the compiler will throw a warning
    throwWarning();
    
    // compiler warning (here: gcc 12.0)
    /*
    prog.cc: In function 'int main()':
    prog.cc:19:17: warning: ignoring returned value of type 'ErrorCode', declared with attribute 'nodiscard': 'Don't discard the error code' [-Wunused-result]
   19 |     throwWarning();
      |     ~~~~~~~~~~~~^~
    prog.cc:14:11: note: in call to 'ErrorCode throwWarning()', declared here
   14 | ErrorCode throwWarning() { return ErrorCode::Fatal; }
      |           ^~~~~~~~~~~~
    prog.cc:6:58: note: 'ErrorCode' declared here
    6 | enum class [[nodiscard("Don't discard the error code")]] ErrorCode {
      |   
    */
}

```

**[[no_unique_address]]**

Drückt aus, dass dieses Mitglied einer Klasse keine Adresse benötigt,  die sich von allen anderen nichtstatischen Mitgliedern der Klasse  unterscheidet. Dadurch kann ein Compiler konsequenterweise den Speicherplatz optimieren. 

## consteval und constinit

Mit *consteval* erzeugt man eine sogenannte Immediate-Funktion. Jeder Aufruf erzeugt einen konstanten Ausdruck, der zur Compilezeit ausgewertet werden kann. Ist also implizit eine *constexpr*-Funktion. *consteval* kann nicht auf Destruktoren oder Funktionen angewandt werden, die Speicher allokieren oder freigeben. 

```c++
/// C++20: consteval
#include <iostream>

consteval int square(int n) 
{
   return n*n;
}

int main() 
{  
   constexpr int res = square(42); 
    
   std::cout << "res " << res << std::endl;
}

///> res 1764
```

*constinit* gibt die Garantie, dass eine Variable mit statischer Speicherdauer zur Compilezeit initialisiert wird. 

```c++
/// C++20: constinit
#include <iostream>

consteval int sqr(int n) 
{
   return n * n;
}

/// constexpr and constinit possible as res1 and res2 have static memory
constexpr auto res1 = sqr(5);                  
constinit auto res2 = sqr(5);                  

int main() 
{
   std::cout << "constexpr sqr(5): " << res1 << std::endl;
   std::cout << "constinit sqr(5): " << res2 << std::endl;
}

///> constexpr sqr(5): 25
///> constinit sqr(5): 25
```

Was sind dann die Unterschiede zu *constexpr*? Sowohl *constinit*- als auch *constexpr*-Variablen werden zur Compilezeit initialisiert. *constinit* impliziert aber nicht die Konstantheit einer Variablen; im Gegensatz zu *constexpr*. 

```c++
/// C++20: constinit
#include <iostream>

/// constexpr and constinit initialized during compile-time
constexpr int constexpr_var = 42;
constinit int constinit_var = 42;

int main() 
{
   std::cout << "constexpr_var " << constexpr_var << std::endl;
   std::cout << "constinit_var " << constinit_var << std::endl;
    
   /// actually we can modify the constinit ....
   std::cout << "++constinit_var: " << ++constinit_var << std::endl;   
    
   // but it's impossible to modify the constexpr
   ///std::cout << "++constexpr_var: " << ++constexpr_var << std::endl;   //--> compile error
}

/// constexpr_var 42
/// constinit_var 42
/// ++constinit_var: 43
```

## constexpr-container and algorithms

Viele Algorithmen aus der STL haben schon ein *constexpr*-Pendant.

Mit C++20 werden jetzt auch *constexpr*-Container *std::vector* und *std::string* unterstützt. Bedeutet: die Methoden beider Container können zur Compilezeit ausgeführt werden.

Details können in [19] nachgelesen werden. 

Am Beispiel eines *std::array* kann man schön den Effekt sehen. *std::array* deshalb, weil *std::array* seit C++17 ein *constexpr*-Container ist. Leider können die aktuellen Compiler clang v14 und gcc v12 noch nicht mit *std::vector* und/oder *std::string* *constexpr* umgehen. 

```c++
// C++20 constexpr std::vector 
#include <algorithm>
#include <iostream>
#include <numeric>
#include <vector>
#include <array>
#include <chrono>

int main() 
{
    std::cout << std::endl;
    std::cout << "hallo" << std::endl;

    constexpr std::array myArray{1, 2, 3, 4, 5};
    auto start = std::chrono::high_resolution_clock::now();
    constexpr auto sum = std::accumulate(myArray.begin(), myArray.end(), 0);
    auto stop = std::chrono::high_resolution_clock::now();
    std::cout << "sum: "  << sum << std::endl;

    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    std::cout << "duration constexpr std::array accu = " << duration.count() << " microseconds\n";

    std::cout << "\n\n";
}

//>hallo
//>sum: 15
//>duration constexpr std::array accu = 0 microseconds
```



## Concurrency

### std::atomic

**std::atomic_ref**

Das Klassen-Template *std::atomic_ref* bietet atomare Operationen auf das referenzierte, nicht atomare Objekt an. Gleichzeitiges Lesen und Schreiben auf ein Objekt ist damit kein Data Race mehr.

```c++
/// Examples using C++20 atomic_ref
#include <iostream>
#include <atomic>

int main() {
    int value{41};
    int& ref = value;

    /// using std::atomic we do not increment our reference value 
    /// but the atomic reference only as it is a copy
    std::atomic<int> atomicRef(ref);
    ++atomicRef;                    
    std::cout << "ref: " << ref << std::endl;
    std::cout << "std::atomic: " << atomicRef.load() << std::endl;

    /// using std::atomic_ref we really use the referenced value
    std::atomic_ref<int> atomicRef2(ref);
    ++atomicRef2;
    std::cout << std::endl;
    std::cout << "ref: " << ref << std::endl;
    std::cout << "std::atomic_ref: " << atomicRef2.load() << std::endl;
    
}

//>ref: 41
//>std::atomic: 42

//>ref: 42
//>std::atomic_ref: 42
```

**std::atomic_flag**

Das *std::atomic_flag* wurde in C++11 eingeführt. In C++11 hat es eine simple Schnittstelle. Zum einen gibt es *clear*, um seinen Wert auf *false* zu setzen. Und eine Funktion *test_and_set* um seinen Wert auf *true* zu setzen.

Mit C++20 bekommt *std::atomic_flag* neue Funktionen. Es gibt jetzt *atomicFlag.wait(), atomictFlag.notify_one()* und *atomicFlag.notify_all()*. Zusätzlich kann man mit *atomicFlag.test()* den Wert des *std::atomic_flag* abfragen. Damit kann ich einfache Thread-Synchronisationen programmieren. Ähnlich wie wenn ich *future/promise* Paare verwende. 

```c++
#include <iostream>
#include <thread>
#include <vector>
#include <atomic>

std::vector<int32_t> myVec {};

std::atomic_flag atomicFlag{};

void prepareWork() {
    myVec.insert(myVec.end(), {0, 1, 0, 3});
    std::cout << "Sender prepared" << std::endl;
    atomicFlag.test_and_set();
    atomicFlag.notify_one();
}

void completeWork() {
    std::cout << "Worker waiting for data" << std::endl;
    atomicFlag.wait(false);
    myVec.push_back(0);
    myVec.push_back(4);
    std::cout << "Worker completed the work" << std::endl;
    for (auto i: myVec) std::cout << i << " ";
}

int main() {

    std::thread t1(prepareWork);
    std::thread t2(completeWork);

    t1.join();
    t2.join();
    
    return 0;
}

//> Worker waiting for data
//> Sender prepared
//> Worker completed the work
//> 0 1 0 3 0 4 
```

### Floating point atomics

**Atomare Shared Pointer und Weak Pointer**

Shared Pointer und Weak Pointer gibt es jetzt auch atomar. 

**Atomare Gleitkommazahlen**

Seit C++11 gibt es schon atomare Ganzzahlen. Mit C++20 bekommen wir atomare Gleitkommazahlen. 

### **Semaphoren, Latches und Barriers** 

Mit C++20 bekommen wir eine eingebaute Semaphore-Implementierung. 

Mit *Latches* und *Barriers* werden einfache Synchronisationsmechanismen eingeführt. Sie erlauben es, Threads zu blockieren, bis ein Zähler den Wert 0 besitzt. 

Ein *std::latch* kann nur einmal verwendet werden. Ein *std::barrier* lässt sich mehrmals verwenden.

```c++

```

### std::jthread

**Joining Thread**

Ein Joining Thread (*std::jthread*) 'joint' automatisch und er kann auch unterbrochen werden. Mit *std::thread* aus C++11 war das bisher nicht möglich. 

```c++

```

## use of using enum

In C++20 ist es jetzt möglich, die *using*-Anweisung zu nutzen, um den Namen des *Enums* im Bereich bekannt zu machen. 

```c++
/**
 * C++20 using declarations for enums example
 */
#include <stdio.h>
#include <iostream>
#include <type_traits>

// scoped enum specifying underlying type 
enum class Color: std::uint8_t 
{
   red = 0x1,
   blue = 0x2, 
   green = 0x3,
};

// this function demonstrates the usage of a using declaration for scoped enums
std::string_view what_color(Color color)
{
   switch (color)
   {
      /// NOTE:I used gcc 11.1.0 to be able to compile this using option -C++2a
      using enum Color;   
      case red: return "red"; break;
      case blue: return "blue"; break;
      case green: return "green"; break;
      default: return ""; break;
   }
}

int main()
{  
   // before c++17 I had to use a static_cast
   Color my_favourite_color{static_cast<Color>(0x3)};
   std::cout << "my favourite color is " << +static_cast<std::underlying_type_t<Color> >(my_favourite_color) << "\n";
   
   // C++17 simplifies it
   Color my_cpp17_favourite_color{0x2};
   std::cout << "my new favourite color is " << +static_cast<std::underlying_type_t<Color> >(my_cpp17_favourite_color) << "\n";
    
   std::cout << "in other words my new favourite is " << what_color(my_cpp17_favourite_color) << std::endl;
      
   return 0;
}

///> my favourite color is 3
///> my new favourite color is 2
///> in other words my new favourite is blue
```

## volatile

C++20 führt eine Neudefinition von *volatile* ein. Kurz: Mit dem Schlüsselwort *volatile* verhindert man aggressive Optimierung des Compilers. Allerdings besitzt *volatile* keine Multithreading-Semantik. 

Einige unschöne Eigenschaften von *volatile* wurden auf *deprecated* gesetzt. Siehe dazu die Präsentation "[Deprecating volatile](https://www.youtube.com/watch?v=KJW_DLaVXIY)" (CppCon 2019) von JF Bastien.

## UTF-8 Strings: char8_t

C++20 erhält den neuen Zeichentyp *char8_t*. Er ist groß genug, um UTF-8 (8 Bits) zu repräsentieren. Natürlich gibt es dazu auch einen neuen UTF-8 String Literal *u8*.

```c++
// char8Str.cpp
#include <iostream>
#include <string>

int main() 
{
    std::basic_string<char8_t> char8String = u8"helloWorld";
    std::u8string char8String2 = u8"helloWorld";
    
    std::cout << "char8String.size(): " << char8String.size() << std::endl;
    std::cout << "char8String2.size(): " << char8String2.size() << std::endl;
    
}

//> char8String.size(): 10
//> char8String2.size(): 10
```

## Bitfeld Default-Initialisierung

Mit C++20 lassen sich die Mitglieder eines Bitfelds mit Default-Initialisierung nutzen.

```c++
// C++20 Default Initialisation of a Bitfield 
#include <iostream>

struct SimpleClass 
{
    // we need 32bit/int = 32bit * 6 = 24 Bytes
    int i = 1;
    int j = 2;
    int k = 3;
    int l = 4;
    int m = 5;
    int n = 6;
};

struct BitField 
{
    // we need 3 + 4 + 5 + 6 + 7 + 7 = 32bit = 4 Bytes
    int i : 3 = 1;
    int j : 4 = 2;
    int k : 5 = 3;
    int l : 6 = 4;
    int m : 7 = 5;
    int n : 7 = 6;
};

int main () 
{  
    std::cout << std::endl;

    std::cout << "sizeof(SimpleClass): " << sizeof(SimpleClass) << std::endl;
    std::cout << "sizeof(BitField): " << sizeof(BitField) << std::endl;
    
    std::cout << std::endl;
    
}

//> sizeof(SimpleClass): 24
//> sizeof(BitField): 4
```

## Bit-Manipulationen

### std::endian

Mit *std::endian* kann ich jetzt einfach meine Platform auf *big-endian* oder *little-endian* überprüfen.

```c++
/// C++20 std::endian
#include <bit>
#include <iostream>

int main() {
    if constexpr (std::endian::native == std::endian::big) {
        std::cout << "big-endian" << '\n';
    }
    else if constexpr (std::endian::native == std::endian::little) {
        std::cout << "little-endian"  << '\n'; 
    }
}
//> little-endian
```

### Manipulationen

Es gibt jetzt viele Funktionen, mit denen man Bit-Sequenzen untersuchen bzw. manipulieren kann. 

| Funktion       | Beschreibung                                                 |
| -------------- | ------------------------------------------------------------ |
| bit_cast       | Interpretiert ein Objekt neu                                 |
| has_single_bit | Prüft, ob eine Zahl eine ganze Potenz von zwei ist           |
| bit_ceil       | Findet die kleinste integrale Zweierpotenz, die nicht kleiner als der gegebene Wert ist |
| bit_floor      | Findet die kleinste integrale Zweierpotenz, die nicht größer als der gegebene Wert ist |
| bit_with       | Findet die kleinste Anzahl an Bits, die benötigt werden um den gegebenen Wert darzustellen |
| rotl           | Gibt das Ergebnis einer bitweisen Linksrotation zurück       |
| rotr           | Gibt das Ergebnis einer bitweisen Rechtsrotation zurück      |
| countl_zero    | Zählt die Anzahl zusammenhängender 0-Bits, startend beim höchstwertigsten Bit |
| countl_one     | Zählt die Anzahl zusammenhängender 1-Bits, startend beim höchstwertigsten Bit |
| countr_zero    | Zählt die Anzahl zusammenhängender 0-Bits, startend beim niedrigstwertigsten Bit |
| countr_one     | Zählt die Anzahl zusammenhängender 1-Bits, startend beim niedrigstwertigsten Bit |
| popcount       | Zählt die Anzahl Bits in einem vorzeichenlosen integer       |
| endian         | Gibt die Byte-Reihenfolge zurück                             |

```c++
// C++20 Bit Manipulationen
#include <bit>
#include <bitset>
#include <iostream>
 
int main() {
    
    std::uint8_t num = 0b01011100;
    std::uint8_t powertwo = 0b00000100;
    
    std::cout << std::boolalpha;
    
    std::cout << "std::has_single_bit(0b01011100): " 
              << std::has_single_bit(num) << '\n';

    std::cout << "std::has_single_bit(0b00000100): " 
              << std::has_single_bit(powertwo) << '\n';
}

//> std::has_single_bit(0b01011100): false
//> std::has_single_bit(0b00000100): true
```



## Algorithmen

**std::find, std::find_if, std::find_if_not**

Da habe ich schon lange darauf gewartet. Endlich gibt es Suchfunktionen für die Containerklassen. Das vereinfacht das Leben doch enorm. Zum Beispiel wenn ich mir die Frage nach dem Sinn des Lebens stelle. 

```c++
// C++20 find example
#include <iostream>
#include <vector>

int main()
{
   std::cout << "Hello, Wandbox!" << std::endl;
    
   std::vector<int> myvector {1, 10, 1000, 4, 42, 399};
    
   // Find die Antwort auf den Sinn des Lebens in einer Zeile Code!
   auto result = std::find(myvector.begin(), myvector.end(), 42);
   
   if (result!=std::end(myvector))
   {
      std::cout << "Found the answer\n";
   }
   else 
   {
      std::cout << "Didn't find the answer\n"; 
   }
   std::cout << std::endl;
}

//>Found the answer
```

## Version

In C++20 kann man mit der Header-Datei <version> nach Unterstützung von Features des C++20 Standards (und späterer) fragen. Auf der Seite von [cppreference](https://en.cppreference.com/w/cpp/feature_test) kann man sich einen Überblick über die Möglichkeiten verschaffen. 

```c++
/// Ein Beispielprogramm kann in https://en.cppreference.com/w/cpp/feature_test eingesehen werden. 
```



## Bibliothek 

### chrono

Die chrono-Bibliothek (die schon seit C++11/C++14 exisitiert) wurde um einen Kalender und um Zeitzonen erweitert. Damit ist es nun möglich:

- ein Datum in verschiedenen Formaten zu repräsentieren
- den letzten Tag eines Monats zu bestimmen
- die Anzahl der Tage zwischen zwei Daten zu bestimmen
- die Ausgabe der aktuellen Zeit in verschiedenen Zeitzonen zu bestimmen
- es gibt zwei neue Literale: *d* für einen Tag und *y* für ein Jahr
- der "/" Operator kann zum Umgang mit Zeitpunkten verwendet werden
- Zeitzonen: Zeitpunkte lassen sich in verschiedenen Zeitzonen darstellen

```c++
/// C++20: chrono
/// Examples using the C++20 chrono library
#include <iostream>
#include <chrono>

using namespace std::chrono_literals;

void timeOfDay() {
    /// detects whether the 24-hour format is a.m.
    auto am = std::chrono::is_am(10h);  
    std::cout << std::boolalpha ; 
    std::cout << "10h is am " << am; 
    am = std::chrono::is_am(22h);
    std::cout << "\n22h is am " << am;

    /// make 12-hour format from given hour
    std::cout << "\nmake12(5h): " << std::chrono::make12(5h);
    std::cout << "\nmake12(15h): " << std::chrono::make12(15h) << '\n';

    /// time of day since last midnight - timeOfDay is used as formatter
    auto timeOfDay = std::chrono::hh_mm_ss(14h + 11min + 20s + 0.5s); 
    
    std::cout << "timeOfDay.hours(): " << timeOfDay.hours() << '\n';
    std::cout << "timeOfDay.minutes(): " << timeOfDay.minutes() << '\n';
    std::cout << "timeOfDay.seconds(): " << timeOfDay.seconds() << '\n';    
}

// here we're using the time literals e.g.
// 1940y for Year
// 26d for Day
// std::chrono::June for Month
void calendar() {
    std::cout << std::endl;

    /// using ::year_month_day I can create a calendar day 
    constexpr auto ymd = std::chrono::year_month_day(1940y, std::chrono::June, 26d);

    std::cout << "Current Year: " << static_cast<int>(ymd.year()) << ", "
                 "Month: " << static_cast<unsigned>(ymd.month()) << ", "
                 "Day: " << static_cast<unsigned>(ymd.day()) << "\n";

    /// last day of March in year 2010
    const std::chrono::year_month_day_last ymdl{2010y / std::chrono::March / std::chrono::last};
    std::cout << "last day of March 2010 is " << static_cast<unsigned>(ymdl.day());
    std::cout << std::endl;

    /// you can use 'year/month/day' syntax
    constexpr auto ymd2 = std::chrono::year_month_day{2023y / std::chrono::September / 26d};
    std::cout << "Current Year: " << static_cast<int>(ymd2.year()) << ", "
                 "Month: " << static_cast<unsigned>(ymd2.month()) << ", "
                 "Day: " << static_cast<unsigned>(ymd2.day()) << "\n";
}    

// check if a date is valid
void date() {     
    std::cout << std::endl;
    
    // Day 31
    std::chrono::day day31(31);
    // create Day 32 which is one more than Day 31
    std::chrono::day day32 = day31 + std::chrono::days(1);
    // Yes - Day 31 is a valid day
    std::cout << "day31.ok(): " << day31.ok() << '\n';
    // No - Day 32 is invalid 
    std::cout << "day32.ok(): " << day32.ok() << std::endl;
}

// some more fun - I mean some more queries 
void queries() {
    std::cout << std::endl;
    
    // output current time 
    auto now = std::chrono::system_clock::now();    // since C++11
    const std::time_t time_now = std::chrono::system_clock::to_time_t(now);
    std::cout << "The system clock is currently at " << std::ctime(&time_now);

    // my birthday
    auto birthday = std::chrono::year(1971)/std::chrono::month(9)/std::chrono::day(10);  
    // check if birthday is really ok
    if (not birthday.ok()) {
        std::exit(EXIT_FAILURE);
    }

    auto birthdayWeekday = std::chrono::year_month_weekday(birthday);
    auto my_weekday = birthdayWeekday.weekday();
    //std::cout << "my_weekday " << my_weekday << '\n';
    static_cast<void>(my_weekday);
}

void timezones() {
    std::cout << std::endl;
    
    // current time UTC
    auto utcTime = std::chrono::system_clock::now();
    // cut current time to seconds 
    auto secs = std::chrono::floor<std::chrono::seconds>(utcTime);
    static_cast<void>(secs);
}

int main() {
    std::cout << "Hallo" << std::endl;

    timeOfDay();
    calendar();
    date();
    queries();
    timezones();
}

///>10h is am true
///>22h is am false
///>make12(5h): 5h
///>make12(15h): 3h
///>timeOfDay.hours(): 14h
///>timeOfDay.minutes(): 11min
///>timeOfDay.seconds(): 20s

///>Current Year: 1940, Month: 6, Day: 26
///>last day of March 2010 is 31
///>Current Year: 2023, Month: 9, Day: 26

///>day31.ok(): true
///>day32.ok(): false

///>The system clock is currently at Sun Oct  1 13:22:08 2023
```

Für Beispiele siehe auch [18]. Nach einigem Rumprobieren muss ich allerdings gestehen: einfach und verständlich sind manche Funktionalitäten nicht und es benötigt eine gewisse Einarbeitungszeit, um die neuen Funktionalitäten aus C++20 gewinnbringend einzusetzen.

Zusätzlich sind die aktuellen Compiler nötig z.B. gcc 12.2.0.

Eine kurze Übersicht zu time-of-day.

| Funktion                                                   | Beschreibung                                                 |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| timeOfDay.hours()                                          | Stunden seit Mitternacht                                     |
| timeOfDay.minutes()                                        | Minuten seit Mitternacht                                     |
| timeOfDay.seconds()                                        | Sekunden seit Mitternacht                                    |
| timeOfDay.subseconds()                                     | Bruchteil von Sekunden seit Mitternacht                      |
| timeOfDay.to_duration()                                    | Zeitdauer (vergangene Zeit) seit Mitternacht                 |
| std::chrono::make12(hours)<br />std::chrono::make24(hours) | 12-Stunden (24-Stunden) Äquivalent einer 24 Stunden (12 Stunden) Zeit |
| std::chrono::is_am(hours)<br />std;:chrono::is_pm(hours)   | Ermittelt, ob die Zeit a.m. oder p.m. ist                    |



### utilities 

Die *utilities*-Bibliothek beinhaltet Funktionen, um *Integer* (Ganzzahlen) sicher zu vergleichen. Schau dir das Beispiel an. 

```c++
/// Examples using C++20 safe integer compare functions
#include <iostream>
#include <utility>

int main() {

    std::cout << "Hallo" << std::endl;

    std::cout << std::boolalpha;

    int x = -3;               
    unsigned int y = 7;  

    // complete fail as the C/C++ language implicitely cast signed int to unsigned int!
    std::cout << "-3 < 7:  " << (x < y) << std::endl;
    std::cout << "-3 <= 7: " << (x <= y) << std::endl;
    std::cout << "-3 > 7:  " << (x > y) << std::endl;
    std::cout << "-3 => 7: " << (x >= y) << std::endl;

    std::cout << std::endl;

    // C++20 introduces safety comparison functions for integer
    // std::cmp_equal, std::cmp_not_equal, std::cmp_less, std::cmp_less_equal, std::cmp_greater, std::cmp_greater_equal

    std::cout << "-3 < 7:  " << std::cmp_less(x, y) << std::endl;
    std::cout << "-3 <= 7: " << std::cmp_less_equal(x, y) << std::endl;
    std::cout << "-3 > 7:  " << std::cmp_greater(x, y) << std::endl;
    std::cout << "-3 => 7: " << std::cmp_greater_equal(x, y) << std::endl;
}

///>-3 < 7:  false
///-3 <= 7: false
///-3 > 7:  true
///-3 => 7: true

///-3 < 7:  true
///-3 <= 7: true
///-3 > 7:  false
///-3 => 7: false
```

Achtung: Aus meiner Sicht ist die 'blinde' Verwendung dieser Funktionen gefährlich. Folgt man Clean-Code Prinzipien sollte man im obigen Beispiel signed und unsigned Werte natürlich nie und nimmer miteinander kombinieren. 

### numbers

Es gibt jetzt eine Header-Datei <numbers>, welche mathematische Konstanten beinhaltet. 

| Konstante  | Bedeutung                  |
| ---------- | -------------------------- |
| e          | Eulersche Zahl *e*         |
| log2e      | log<sub>2</sub>e           |
| log10e     | log<sub>10</sub>e          |
| pi         | PI                         |
| inv_pi     | 1/PI                       |
| inv_sqrtpi | Inverse von Wurzel PI      |
| ln2        | 2er Logarithmus            |
| ln10       | 10er Logarithmus           |
| sqrt2      | zweite Wurzel              |
| sqrt3      | dritte Wurzel              |
| inv_sqrt3  | Inverse von dritter Wurzel |
| egamma     | Euler-Mascheroni-Konstante |
| phi        | Goldener Schnitt           |

```c++
/// C++20 mathemetical constants 
#include <iomanip>
#include <iostream>
#include <numbers>

int main() {
    
    std::cout<< std::setprecision(10);
    
    std::cout << "std::numbers::e: " <<  std::numbers::e << std::endl; 
    std::cout << "std::numbers::log2e: " <<  std::numbers::log2e << std::endl; 
    std::cout << "std::numbers::log10e: " <<  std::numbers::log10e << std::endl; 
    std::cout << "std::numbers::pi: " <<  std::numbers::pi << std::endl; 
    std::cout << "std::numbers::inv_pi: " <<  std::numbers::inv_pi << std::endl;
    std::cout << "std::numbers::inv_sqrtpi: " <<  std::numbers::inv_sqrtpi << std::endl; 
    std::cout << "std::numbers::ln2: " <<  std::numbers::ln2 << std::endl; 
    std::cout << "std::numbers::sqrt2: " <<  std::numbers::sqrt2 << std::endl; 
    std::cout << "std::numbers::sqrt3: " <<  std::numbers::sqrt3 << std::endl; 
    std::cout << "std::numbers::inv_sqrt3: " <<  std::numbers::inv_sqrt3 << std::endl;
    std::cout << "std::numbers::egamma: " <<  std::numbers::egamma << std::endl;
    std::cout << "std::numbers::phi: " <<  std::numbers::phi << std::endl;
    
}

///>std::numbers::e: 2.718281828
///>std::numbers::log2e: 1.442695041
///>std::numbers::log10e: 0.4342944819
///>std::numbers::pi: 3.141592654
///>std::numbers::inv_pi: 0.3183098862
///>std::numbers::inv_sqrtpi: 0.5641895835
///>std::numbers::ln2: 0.6931471806
///>std::numbers::sqrt2: 1.414213562
///>std::numbers::sqrt3: 1.732050808
///>std::numbers::inv_sqrt3: 0.5773502692
///>std::numbers::egamma: 0.5772156649
///>std::numbers::phi: 1.618033989
```

### span

*std::span* steht für ein Objekt, das sich auf eine zusammenhängende Sequenz von Objekten bezieht. Der zusammenhängende Bereich kann ein Array, ein Zeiger oder auch ein *std::vector* sein.

*std::span* bestimmt automatisch die Länge eines C-Arrays, eines *std::vector* oder eines *std::array*. 

Also: Falls du ein Array oder einen Vektor an eine Funktion übergeben willst, dann nutze den *std::span*-Container. 

```c++
// C++20 std::span
#include <iostream>
#include <span>

/// Use the array/vector as parameter but need to add a size parameter
template<typename T>
void copyN(T* src, T* dest, int n)
{
   for (int i=0; i<n; i++)
   {
      dest[i] = src[i];
   }
}

/// Simpler: use std::span which implicit contains the size of the array/vector
void copySpan(std::span<int> src, std::span<int> dest)
{
   std::cout << "src size " << src.size() << "\n";
   std::cout << "dest size " << dest.size() << "\n";
   
   if (dest.size() < src.size())
   {
      return;
   }
   
   if (src.size() >= 2)
   {
      std::cout << "src[0] " << src[0] << "\n";
   }
   
   for (int i=0; i<src.size(); i++)
   {
      dest[i] = src[i];
   }
   
   return;
}

int main()
{
   int arr1[] = {1, 2, 3};
   int arr2[] = {3, 4, 5};
  
   copyN(arr1, arr2, 3);
   std::cout << "copyN ";
   for (int i=0; i<3; i++)
   {
      std::cout << " " << arr2[i];
   }
   std::cout << std::endl;
   
   // Usage of std::span. No need to add the array length.
   // This is much more convenient and reduces the risk of a size mismatch.
   copySpan(std::span{arr1}, std::span{arr2});
   
   return 0;
}

///> copyN  1 2 3
///> std::span(src) size 3
///> std::span(dest) size 3
///> src[0] 1
```

Ein *std::span* kann auch mithilfe eines Zeigers und einer Länge erzeugt werden.

```c++
// C++20 std::span creation
#include <algorithm>
#include <iostream>
#include <span>
#include <vector>

int main() 
{
    std::cout << std::endl;
    std::cout << std::boolalpha;

    std::vector myVec{1, 2, 3, 4, 5};

    /// create span by using constructor initialisation
    std::span mySpan1{myVec};                          

    /// create span by using pointer and size
    std::span mySpan2{myVec.data(), myVec.size()};
    
    bool spansEqual = std::equal(mySpan1.begin(), mySpan1.end(),
                                 mySpan2.begin(), mySpan2.end());
    
    std::cout << "mySpan1 == mySpan2: " << spansEqual << std::endl; 

}
```

### format

Die *std::format* Bibliothek bietet jetzt eine Alternative zur printf-Funktionalität. 

```c++
/// C++20: format
#include <iostream>
#include <format>
 
int main()
{
   std::string message = std::format("The answer is {}.", 42);
}
```

### std::erase und std::erase_if

 In C++20 wurden die Funktionen std::erase und std::erase_if eingeführt, um das erase-remove-Idiom simpel mit einer Funktion zu unterstützen. 

```c++
// C++20 - Examples if std::erase and std::erase_if which are useful for implementing erase-remove-idiom
#include <vector>
#include <algorithm>
#include <numeric>
#include <iostream>

template<typename Cont> void printContainer(Cont& cont) {
    for (auto elem: cont) std::cout << elem << " ";
    std::cout << "\n"; 
}

int main()
{
    std::vector myVec{-2, 3, -5, 10, 3, 0, -5 };
    printContainer(myVec);

    /// erase/remove all elements with value '-5'
    std::erase(myVec, -5); 
    printContainer(myVec);

    /// erase/remove all elements with value >= 5
    std::erase_if(myVec, [](auto i) { return i >= 5; } );
    printContainer(myVec);

    // erase/remove all spaces in a string
    std::string str{"Lorem ipsum dolor sit amet, consetetur sadipscing elitr"};
    std::cout << "str: " << str << std::endl;
    std::erase(str, ' ');                                     
    std::cout << "str: " << str << std::endl;
}

///> -2 3 -5 10 3 0 -5 
///> -2 3 10 3 0 
///> -2 3 3 0 
///> str: Lorem ipsum dolor sit amet, consetetur sadipscing elitr
///> str: Loremipsumdolorsitamet,consetetursadipscingelitr
```

### std::contain for associative containers

Assoziative Container wie set, multiset, map, multimap beinhalten nun eine Funktion contains, mit der man den Container auf ein Element hin simpel überprüfen kann.

```c++
// C++20 - Really simple example of new contains-function for associative containers
#include <set>
#include <iostream>

int main()
{
    std::cout << std::boolalpha;
    std::cout << std::endl;
    
    std::set<int> mySet{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    std::cout << "mySet contains element 5: " << mySet.contains(5);
}

///> mySet contains element 5: true
```

### std::midpoint

*std::midpoint* berechnet den Mittelpunkt zweier Integrale, zweier Gleitkommazahlen oder zweier Zeiger. 
```c++
/// Simple examples of std::midpoint and std::lerp

#include <cmath>     // std::lerp
#include <numeric>   // std::midpoint
#include <iostream>

int main() {

    // std::midpoint is allowed on integers, floating-point, and pointers 
    // calculating (a + (b - a) / 2) 
    std::cout << "std::midpoint(10, 20): " << std::midpoint(10, 20) << std::endl;
    
    std::cout << std::endl;

    /// std::lerp(a, b, t) calculates the linear interpolation (a + t(b - a))
    for (auto v: {0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0}) {
        std::cout << "std::lerp(10, 20, " << v << "): " << std::lerp(10, 20, v) << std::endl;
        }
}
```

### std::lerp

*std::lerp(a, b, t)*  berechnet die lineare Interpolation (a + t(b - a)).
```c++
/// Simple examples of std::midpoint and std::lerp

#include <cmath>     // std::lerp
#include <numeric>   // std::midpoint
#include <iostream>

int main() {

    // std::midpoint is allowed on integers, floating-point, and pointers 
    // calculating (a + (b - a) / 2) 
    std::cout << "std::midpoint(10, 20): " << std::midpoint(10, 20) << std::endl;
    
    std::cout << std::endl;

    /// std::lerp(a, b, t) calculates the linear interpolation (a + t(b - a))
    for (auto v: {0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0}) {
        std::cout << "std::lerp(10, 20, " << v << "): " << std::lerp(10, 20, v) << std::endl;
        }
}
```

### std::to_array

Man kann jetzt einfach ein std::array aus einem C-Array mit std::to_array erzeugen.
```c++
// C++20 std::to_array example
#include <type_traits>
#include <utility>
#include <array>
#include <iostream>
 
int main() {
  
    auto arr1 = std::to_array("C-String Literal");
    static_assert(arr1.size() == 17);  
 
    auto arr2 = std::to_array({ 0, 2, 1, 3 });         
    static_assert(std::is_same<decltype(arr2), std::array<int, 4>>::value); 
}
```

### std::make_shared

Seit C++11 gibt es ja schon die Fabrikfunktion *std::make_shared*. Mit C++20 unterstützt std::make_shared auch C-Arrays, mit denen sich std::shared_ptr von C-Arrays erzeugen lassen. 
```c++
/// std::shared_ptr creation - all members will be default initialized
auto s1 = std::make_shared<double[]<(1024);
```

### std::string starts_with and ends_with

Die neuen Funktionen *starts_with* und *ends_with* prüfen, ob ein *std::string* mit einem vorgegebenen String beginnt oder endet. 
```c++
// C++20 std::string::starts_with and ::ends_with examples
#include <iostream>
#include <string>

int main()
{
   std::string helloworld("Hello World");

   std::cout << helloworld << std::endl;

   std::cout << std::boolalpha; 

   std::cout << "Starts with Hello " << helloworld.starts_with("Hello") << std::endl;

   std::cout << "End with World " << helloworld.ends_with("World") << std::endl;
}
//>Hello World
//>Starts with Hello true
//>Ends with World true
```

### std::bind_front 

*std::bind_front* erzeugt einen aufrufbaren Wrapper für eine aufrufbare Einheit. 

```c++
// C++20 std::string::starts_with and ::ends_with examples
#include <iostream>
#include <string>
#include <functional>

int plusFunction(int a, int b) {
   return a + b; 
}

int main()
{
   // call plusFunction with two arguments
   std::cout << "Plus 20 + 2000 = " << plusFunction(20, 2000) << std::endl;

   // bind plusFunction (taking two arguments) to twoThousandPlus1 (taking only one argument)
   auto twoThousandPlus1 = std::bind_front(plusFunction, 2000); 
   // and use it - now only one argument necessary 
   std::cout << "twoThousandPlus1(20): " << twoThousandPlus1(20) << std::endl;
   
}
//>Plus 20 + 2000 = 2020
//>twoThousandPlus1(20): 2020
```
### std::is_constant_evaluated

Mit *is_constant_evaluated* kann ich überprüfen, ob eine Funktion zur Compilezeit oder zur Laufzeit ausgeführt wird. 

```c++
/// C++20 is_constant_evaluated
#include <iostream>
#include <type_traits>
#include <cmath>

constexpr double power(double b, int x) {
    if (std::is_constant_evaluated()) {
        std::cout << "compile-time function\n";
        return 1.0;
    } 
    else {
        std::cout << "runtime function\n";
        return std::pow(b, double(x));
    }
}

int main() {    
    std::cout << "Hallo\n";

    //constexpr double kilo1 = power(10.0, 3);
}

/// Leider bekomme ich den Code weder mit gcc 12.2 noch mit clang 16.0.1 zum kompilieren. Grund ist unbekannt. Beispiel findet sich auf https://en.cppreference.com/w/cpp/types/is_constant_evaluated und möglicherweise ist zwingend C++23 bzw. neueste Compiler vonnöten. 
```

### std::source_location

Die Bibliothek *std::source_location* bietet Informationen zum Source Code an wie Dateinamen, Funktionsnamen, Zeile, Spalte an. Und sollten ab C++20 den Vorzug vor den Präprozessor-Makros LINE und FILE haben. 

```c++
/// C++20 source_location
#include <iostream>
#include <source_location>
 
void log() {
   const std::source_location& location = std::source_location::current();
   std::cout << "info:" 
             << location.file_name() << ':' 
             << location.line() << ' ' 
             << '\n';
}
 
int main() {
    std::cout << "Hello world\n"; 
    log();
}
```



## Literatur

[1] <https://herbsutter.com/2017/07/15/trip-report-summer-iso-c-standards-meeting-toronto/>

[2] [https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.htm](https://www.heise.de/developer/meldung/Programmiersprachen-Erste-Plaene-fuer-C-20-veroeffentlicht-3772568.html), abgerufen am 19. November 2018

[3] <https://www.heise.de/developer/meldung/C-20-bekommt-Ranges-und-Erweiterungen-bei-Concepts-4224738.html>, abgerufen am 19. November 2018

[4] <https://herbsutter.com/2018/11/13/trip-report-fall-iso-c-standards-meeting-san-diego/>, abgerufen am 19. November 2018  

[5] https://www.heise.de/developer/meldung/Programmiersprache-Der-Entwurf-von-C-20-ist-abgeschlossen-4317206.html, abgerufen am 25. Februar 2019

[6] Bartek's coding blog, https://www.bfilipek.com/, abgerufen am 12. März 2019

[7] Blog Modernes C++, https://www.heise.de/developer/artikel/Ein-neuer-Thread-mit-C-20-std-jthread-4197595.html, abgerufen am 22. Mai 2019

[8] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Die-vier-grossen-Neuerungen-4568956.html, abgerufen am 05. November 2019

[9] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Kernsprache-4574153.html, abgerufen am 05. November 2019 

[10] Simplify Your Code With Rocket Science: C++20’s Spaceship Operator, https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/, abgerufen am 18. Dezember 2020

[11] Lambdas: From C++11 to C++20, https://www.bfilipek.com/2019/02/lambdas-story-part1.html, abgerufen am 08. November 2019

[12] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Bibliothek-4582224.html, abgerufen am 18. November 2019

[13] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Ueberblick-zur-Concurrency-4585408.html, abgerufen am 14. Dezember 2019

[14] Blog Modernes C++, https://www.heise.de/developer/artikel/C-20-Concepts-die-Details-4599997.html, abgerufen am 16. Januar 2020

[15] C++20 is here!, YouTube, https://www.youtube.com/watch?v=AvPiGstxV_g, abgerufen am 19. Februar 2020

[16] Using C++ Modules in Visual Studio 2017, https://devblogs.microsoft.com/cppblog/cpp-modules-in-visual-studio-2017/, abgerufen am 13. Juli 2020

[17] C++20 Features and Fixes in VS2019 16.1 through 16.6, https://devblogs.microsoft.com/cppblog/c20-features-and-fixes-in-vs-2019-16-1-through-16-6/?utm_source=vs_developer_news&utm_medium=referral, abgerufen am 13. Jul 2020

[18] Howard Hinnant, A date and time library based on the C++11/14/17 <chrono> header, https://github.com/HowardHinnant/date, abgerufen am 21. Dezember 2020

[19] Standard containers and constexpr, http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0784r1.html, abgerufen am 21. Dezember 2020

[20] A library of C++ coroutine abstractions for the coroutines TS, https://github.com/lewissbaker/cppcoro, abgerufen am 05. März 2021

[21] infiniteDataStream.cpp, Rainer Grimm, https://godbolt.org/z/jTS9BR, abgerufen am 05. März 2021

[22] fmt an open-source format library, https://github.com/fmtlib/fmt, abgerufen am 07. Juli 2023

[23] date prototype library from Howard Hinnant, https://github.com/HowardHinnant/date, abgerufen am 04. Dezember 2024

